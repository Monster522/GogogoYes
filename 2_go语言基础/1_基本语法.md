## 基础语法

### 1.Go语言结构

```go
// 包声明-每个go文件必须属于某一个包
package main
// 引入依赖(包)
import "fmt"

// 函数-包括变量,语句,表达式,注释
func main() {
   fmt.Println("Hello, World!")
}
```

### 2.语句组成

- **行分隔符**

  ```go
  fmt.Println("Hello, World!")
  fmt.Println("the manager!")
  ```

  1. 一行代表一个语句结束。每个语句不需要像其它语言一样以分号 ; 结尾，这些工作都将由 Go 编译器自动完成。
  2. 将多个语句写在同一行，则必须使用 ; 人为区分，但是一般不这样做。

- **注释**

  1. 注释不会被编译，每一个包应该有相关注释。

  ```go
  // 单行注释
  /*
   多行注释
   第二行注释
   */
  ```

- **标识符**

  1. 标识符用来命名变量、类型等程序实体。
  2. 一个标识符实际上就是一个或是多个字母(A~Z和a~z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。

  

- **关键字**

  1. 25个关键字或保留字

     | **break 跳出循环for语句**                | **default 选择语句switch** | **func 函数定义**      | **interface 定义接口** | **select**                |
     | ---------------------------------------- | -------------------------- | ---------------------- | ---------------------- | ------------------------- |
     | **case 选择语句switch**                  | **defer 在函数结束前执行** | **go 开启协程**        | **map 数据结构**       | **struct 定义结构体(类)** |
     | **chan**                                 | **else 判断语句if else**   | **goto**               | **package 声明所属包** | **switch 选择语句**       |
     | **const 定义常量**                       | **fallthrough**            | **if 判断语句if else** | **range 遍历for语句**  | **type 自定义类型**       |
     | **continue 忽略此次循环剩余部分for语句** | **for 循环语句**           | **import 引入包**      | **return 返回值方法**  | **var 声明变量**          |

     

  2. 36个预定义标识符

     | append | bool    | byte    | cap     | close  | complex | complex64 | complex128 | uint16  |
     | ------ | ------- | ------- | ------- | ------ | ------- | --------- | ---------- | ------- |
     | copy   | false   | float32 | float64 | imag   | int     | int8      | int16      | uint32  |
     | int32  | int64   | iota    | len     | make   | new     | nil       | panic      | uint64  |
     | print  | println | real    | recover | string | true    | uint      | uint8      | uintptr |

     

  3. 分隔符和标点符号

     - 程序一般由关键字、常量、变量、运算符、类型和函数组成。
     - 程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。
     - 程序中可能会使用到这些标点符号：句号，逗号，分号，冒号和省略号。

- **空格**

  1. Go 语言中变量的声明必须使用空格隔开

     ```go
     var age int;
     ```



## 数据类型

### 1. 分类

   - 布尔型

     布尔型的值只可以是常量 true 或者 false。

   - 数字类型

     整型 int 和浮点型 float，Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。

   - 字符串类型

     字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本。

   - 派生类型

     指针类型(Pointer)、数组类型、结构化类型(Struct)、联合体类型(Union)、函数类型、切片类型、接口类型(interface)、Map类型、Channel类型

### 2. 基本数字类型

   - 整型

     | 类型   | 描述                                                         |
     | ------ | ------------------------------------------------------------ |
     | uint8  | 无符号 8 位整型 (0 到 255)                                   |
     | uint16 | 无符号 16 位整型 (0 到 65535)                                |
     | uint32 | 无符号 32 位整型 (0 到 4294967295)                           |
     | uint64 | 无符号 64 位整型 (0 到 18446744073709551615)                 |
     | int8   | 有符号 8 位整型 (-128 到 127)                                |
     | int16  | 有符号 16 位整型 (-32768 到 32767)                           |
     | int32  | 有符号 32 位整型 (-2147483648 到 2147483647)                 |
     | int64  | 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) |

   - 浮点型

     | 类型       | 描述                  |
     | ---------- | --------------------- |
     | float32    | IEEE-754 32位浮点型数 |
     | float64    | IEEE-754 64位浮点型数 |
     | complex64  | 32 位实数和虚数       |
     | complex128 | 64 位实数和虚数       |


### 3. 其他数字类型

- 特殊的整型

  | 类型    | 描述                         |
  | ------- | ---------------------------- |
  | byte    | 类似 uint8                   |
  | rune    | 类似 int32                   |
  | uint    | 32 或 64 位                  |
  | int     | 与 uint 一样大小             |
  | uintptr | 无符号整型，用于存放一个指针 |




### 4.类型转换

- 类型转换用于将一种数据类型的变量转换为另外一种类型的变量。基本格式为：`type_name(expression)`,type_name 为类型，expression 为表达式。

  ```go
  package main
  
  import "fmt"
  
  func main() {
     var sum int = 17
     var count int = 5
     var mean float32
     
     mean = float32(sum)/float32(count)
     fmt.Printf("mean 的值为: %f\n",mean)
  }
  ```

  

## 变量/常量/运算符

### 1.变量

- **单变量声明**

  ```go
  // 1.指定变量类型，声明后若不赋值，使用默认值
  var a int32
  a = 2
  
  // 2.根据值自行判定变量类型
  var b = 2
  
  // 3.[只能是局部变量]省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误
  c := 2
  ```

  

- **多变量声明**

  ```go
  // 1.类型相同多个变量, 非全局变量
  var a,b,c int32
  a,b,c = 1,2,3
  
  // 2.不需要显示声明类型,自动推断
  var d,e,f = 4,5,6
  
  // 3.[只能是局部变量]出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误
  h,i,j := 7,8,9
  
  // 4.[只能是全局变量]类型不同多个变量
  var (
      q int32
      r string
  )
  ```

  

- **值类型**

  1. 所有像 int、float、bool 和 string 等基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。**值类型的变量的值存储在栈中。**

  2. 可以通过&来获取值类型变量的指针，就是内存地址。如，&i 来获取变量 i 的内存地址，0xf840000040(每次的地址都可能不一样)

     

- **引用类型**

  1. 引用类型一般包含多个基本类型，组成一个比较复杂的数据类型。

  2. 一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址(数字)，或内存地址中第一个字所在的位置，这个内存地址称为指针。

  3. 当使用赋值语句 r2=r1 时，只有引用(地址)被复制。如果r1指向的值被改变了，那么这个值的所有引用都会指向被修改后的内容。

     

- 空白标识符_

  1. 空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。

### 2.常量

- **常量的定义**

  1. 常量是一个简单值的标识符，在程序运行时，不会被修改的量。常量中的数据类型只可以是布尔型、数字型(整数型、浮点型和复数)和字符串型。

  ```go
  // 格式：const identifier [type] = value
  // 显式类型定义
  const b string = "abc"
  // 隐式类型定义
  const b = "abc"
  ```

- **常量用作枚举**

  1. 常量可以用len(), cap(), unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数。

  ```go
  // 普通枚举
  const (
      Unknown = 0
      Female = 1
      Male = 2
  )
  
  // 带有内置函数
  const (
      a = "abc"
      b = len(a)
      c = unsafe.Sizeof(a)
  )
  
  ```

- **特殊常量itoa**

  1. iota，特殊常量，可以认为是一个可以被编译器修改的常量。在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。

  ```go
  const (
      a = iota
      b = iota
      c = iota
  )
  ```

### 3.运算符

- **算术运算符**

  | 运算符 | 描述 | 实例               |
  | ------ | ---- | ------------------ |
  | +      | 相加 | A + B 输出结果 30  |
  | -      | 相减 | A - B 输出结果 -10 |
  | *      | 相乘 | A * B 输出结果 200 |
  | /      | 相除 | B / A 输出结果 2   |
  | %      | 求余 | B % A 输出结果 0   |
  | ++     | 自增 | A++ 输出结果 11    |
  | --     | 自减 | A-- 输出结果 9     |

  

- **关系运算符**

  | 运算符 | 描述                                                         | 实例              |
  | ------ | ------------------------------------------------------------ | ----------------- |
  | ==     | 检查两个值是否相等，如果相等返回 True 否则返回 False。       | (A == B) 为 False |
  | !=     | 检查两个值是否不相等，如果不相等返回 True 否则返回 False。   | (A != B) 为 True  |
  | >      | 检查左边值是否大于右边值，如果是返回 True 否则返回 False。   | (A > B) 为 False  |
  | <      | 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   | (A < B) 为 True   |
  | >=     | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 | (A >= B) 为 False |
  | <=     | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 | (A <= B) 为 True  |

  

- **逻辑运算符**

  | 运算符 | 描述                                                         | 实例               |
  | ------ | ------------------------------------------------------------ | ------------------ |
  | &&     | 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 | (A && B) 为 False  |
  | \|\|   | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 | (A \|\| B) 为 True |
  | !      | 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 | !(A && B) 为 True  |

- **位运算符**

  1. 位运算符对整数在内存中的二进制位进行操作。

  | 运算符 | 描述                                                         | 实例                                   |
  | :----- | :----------------------------------------------------------- | :------------------------------------- |
  | &      | 按位与运算符"&"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 | (A & B) 结果为 12, 二进制为 0000 1100  |
  | \|     | 按位或运算符"\|"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 | (A \| B) 结果为 61, 二进制为 0011 1101 |
  | ^      | 按位异或运算符"^"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 | (A ^ B) 结果为 49, 二进制为 0011 0001  |
  | <<     | 左移运算符"<<"是双目运算符。左移n位就是乘以2的n次方。 其功能把"<<"左边的运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 | A << 2 结果为 240 ，二进制为 1111 0000 |
  | >>     | 右移运算符">>"是双目运算符。右移n位就是除以2的n次方。 其功能是把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数。 | A >> 2 结果为 15 ，二进制为 0000 1111  |

  | p    | q    | p & q | p \| q | p ^ q |
  | ---- | ---- | ----- | ------ | ----- |
  | 0    | 0    | 0     | 0      | 0     |
  | 0    | 1    | 0     | 1      | 1     |
  | 1    | 1    | 1     | 1      | 0     |
  | 1    | 0    | 0     | 1      | 1     |

  

- **赋值运算符**

  | 运算符 | 描述                                           | 实例                                  |
  | :----- | :--------------------------------------------- | :------------------------------------ |
  | =      | 简单的赋值运算符，将一个表达式的值赋给一个左值 | C = A + B 将 A + B 表达式结果赋值给 C |
  | +=     | 相加后再赋值                                   | C += A 等于 C = C + A                 |
  | -=     | 相减后再赋值                                   | C -= A 等于 C = C - A                 |
  | *=     | 相乘后再赋值                                   | C *= A 等于 C = C * A                 |
  | /=     | 相除后再赋值                                   | C /= A 等于 C = C / A                 |
  | %=     | 求余后再赋值                                   | C %= A 等于 C = C % A                 |
  | <<=    | 左移后赋值                                     | C <<= 2 等于 C = C << 2               |
  | >>=    | 右移后赋值                                     | C >>= 2 等于 C = C >> 2               |
  | &=     | 按位与后赋值                                   | C &= 2 等于 C = C & 2                 |
  | ^=     | 按位异或后赋值                                 | C ^= 2 等于 C = C ^ 2                 |
  | \|=    | 按位或后赋值                                   | C \|= 2 等于 C = C \| 2               |

  

- **其他运算符**

  | 运算符 | 描述             | 实例                       |
  | :----- | :--------------- | :------------------------- |
  | &      | 返回变量存储地址 | &a; 将给出变量的实际地址。 |
  | *      | 指针变量。       | *a; 是一个指针变量         |

- **运算符优先级**

  1. 有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。
  2. 可以通过使用括号来临时提升某个表达式的整体运算优先级。

  | 优先级 | 运算符        |
  | :----- | :------------ |
  | 7      | ^ !           |
  | 6      | * / % <> & &^ |
  | 5      | + - \| ^      |
  | 4      | == != < = >   |
  | 3      | <-            |
  | 2      | &&            |
  | 1      | \|\|          |



## 条件语句和循环语句

### 1.条件语句

- 条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。

| 语句           | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| if 语句        | **if 语句** 由一个布尔表达式后紧跟一个或多个语句组成。       |
| if...else 语句 | **if 语句** 后可以使用可选的 **else 语句**, else 语句中的表达式在布尔表达式为 false 时执行。 |
| if 嵌套语句    | 你可以在 **if** 或 **else if** 语句中嵌入一个或多个 **if** 或 **else if** 语句。 |
| switch 语句    | **switch** 语句用于基于不同条件执行不同动作。                |
| select 语句    | **select** 语句类似于 **switch** 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 |



### 2.循环语句

- **循环处理语句**

  | 循环类型                                                     | 描述                                 |
  | :----------------------------------------------------------- | :----------------------------------- |
  | for 循环     | 重复执行语句块                       |
  | 循环嵌套 | 在 for 循环中嵌套一个或多个 for 循环 |

- **循环控制关键字**

  | 控制关键字                                                   | 描述                                             |
  | :----------------------------------------------------------- | :----------------------------------------------- |
  | break 语句 | 经常用于中断当前 for 循环或跳出 switch 语句      |
  | continue 语句 | 跳过当前循环的剩余语句，然后继续进行下一轮循环。 |
  | goto 语句 | 将控制转移到被标记的语句。                       |

- **无限循环**

  可以通过 for 循环语句中只设置一个条件表达式来执行无限循环

  ```go
  package main
  
  import "fmt"
  
  func main() {
      for true  {
          fmt.Printf("这是无限循环。\n");
      }
  }
  ```

  

## 函数和变量作用域

### 1.函数

- **函数的作用**

  1. 函数是基本的代码块，用于执行一个任务。可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。

  2. Go 语言最少有个 main() 函数。语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。

  3. 函数声明告诉了编译器函数的名称，返回类型，和参数。

     

- **函数定义**

  ```go
  func function_name( [parameter list] ) [return_types]{
     函数体
  }
  ```

  1. **func**：函数由 func 开始声明

  2. **function_name**：函数名称，函数名和参数列表一起构成了函数签名。

  3. **parameter list**：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。

  4. **return_types**：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。

  5. **函数体**：函数定义的代码集合。

     

- **函数调用**

  1. 当创建函数时，定义了函数的功能逻辑，通过调用改函数来执行指定任务。调用函数，向函数传递参数，并返回值

     

- **返回多个值**

  ```go
  package main
  
  import "fmt"
  
  func swap(x, y string) (string, string) {
     return y, x
  }
  
  func main() {
     a, b := swap("Mahesh", "Kumar")
     fmt.Println(a, b)
  }
  ```

- **值传递和引用传递**

  1. 默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。
  2. Java中，基本类型传的是具体值，对象类传的是指针值。Go中，基本类型和结构体都是传具体值，&才能传指针。

  | 传递类型                                                     | 描述                                                         |
  | :----------------------------------------------------------- | :----------------------------------------------------------- |
  | 值传递| 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 |
  | 引用传递 | 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 |

- **函数的用法**

  | 函数用法                                                     | 描述                               |
  | :----------------------------------------------------------- | :--------------------------------- |
  | 函数作为值| 函数定义后可作为值来使用           |
  | 闭包 | 闭包是匿名函数，可在动态编程中使用 |
  | 方法  | 方法就是一个包含了接受者的函数     |



### 2.变量作用域

- 作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。Go 语言中变量可以在三个地方声明。

  1. 函数内定义的变量称为局部变量。
  2. 函数外定义的变量称为全局变量。
  3. 函数定义中的变量称为形式参数。

- **变量（局部和全局）初始化值**

  | 数据类型 | 初始化默认值 |
  | :------- | :----------- |
  | int      | 0            |
  | float32  | 0            |
  | pointer  | ni           |

  

- **局部变量**

  在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。

  ```go
  package main
  
  import "fmt"
  
  func main() {
     // 声明局部变量
     var a, b, c int 
  
     // 初始化参数
     a = 10
     b = 20
     c = a + b
  
     fmt.Printf ("结果： a = %d, b = %d and c = %d\n", a, b, c)
  }
  ```

  

- **全局变量**

  在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。全局变量可以在任何函数中使用。

  ```go
  package main
  
  import "fmt"
  
  // 声明全局变量
  var g int
  
  func main() {
  
     // 声明局部变量
     var a, b int
  
     // 初始化参数
     a = 10
     b = 20
     g = a + b
  
     fmt.Printf("结果： a = %d, b = %d and g = %d\n", a, b, g)
  }
  ```

  

- **形式参数**

  形式参数会作为函数的局部变量来使用。

  ```go
  // 声明全局变量
  var a int = 20;
  
  func main() {
     // main 函数中声明局部变量 
     var a int = 10
     var b int = 20
     var c int = 0
  
     fmt.Printf("main()函数中 a = %d\n",  a);
     c = sum( a, b);
     fmt.Printf("main()函数中 c = %d\n",  c);
  }
  
  // 函数定义-两数相加
  func sum(a, b int) int {
     fmt.Printf("sum() 函数中 a = %d\n",  a);
     fmt.Printf("sum() 函数中 b = %d\n",  b);
  
     return a + b;
  }
  ```



## 数组

### 1.数组定义

- 数组是**具有相同唯一类型的一组已编号且长度固定的数据项序列**
  1. 这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。
  2. 数组元素可以通过索引（位置）来读取（或者修改），索引从0开始，第一个元素索引为 0，第二个索引为 1，以此类推。

### 2.声明数组

- 数组声明后，还没有分配具体的内存空间。

```go
// 数组声明必须指定 1.元素类型 2.元素个数，数组长度必须是整数且大于 0。
var variable_name [SIZE] variable_type

// 长度为10，类型为float32
var balance [10] float32
```



### 3.初始化数组

```go
// 1.指定元素类型，元素个数，并在大括号中声明具体数据。初始化数组中 {} 中的元素个数不能大于 [] 中的数字。
var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}

// 2.如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小。
var balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0}

// 3.通过索引初始化
var balance [3]int32
balance[0] = 1
balance[1] = 2
balance[2] = 3
```



### 4.访问数组元素

```go
// 数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。
float32 salary = balance[9]

/**
 数组的基础操作：声明、赋值、访问
**/
package main

import "fmt"

func main() {
   // n 是一个长度为 10 的数组
   var n [10]int 
   var i,j int

   // 为数组 n 初始化元素         
   for i = 0; i < 10; i++ {
      // 设置元素为 i + 100
      n[i] = i + 100 
   }

   // 输出每个数组元素的值
   for j = 0; j < 10; j++ {
      fmt.Printf("Element[%d] = %d\n", j, n[j] )
   }
}
```



## 指针

### 1.内存地址

- 变量是一种占位符，**用于引用计算机内存地址**。Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。

  ```go
  package main
  
  import "fmt"
  
  func main() {
     var a int = 10   
     fmt.Printf("变量的地址: %x\n", &a )
  }
  ```

### 2.指针的定义

- 一个指针变量，可以用来表示任何一个值的内存地址，指针(内存地址) -> 具体值(其他类型)

  1. 非指针变量，会自动获取其内存地址所代表的具体值。
  2. 指针变量，不会解析内存地址，只显示内存地址值。

- **声明指针**

  ```go
  // 声明格式：var-type为指针类型，var_name为指针变量名，* 号用于指定变量是作为一个指针。
  var var_name *var-type
  
  // 指针声明实例
  var ip *int        // 指向整型
  var fp *float32    // 指向浮点型
  ```

  

### 3.具体使用

- **使用流程**

  1. 定义指针变量。
  2. 为指针变量赋值。
  3. 访问指针变量中指向地址的值。在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。

  ```go
  package main
  
  import "fmt"
  
  func main() {
    // 声明实际变量
    var a int= 20   
    // 声明指针变量
    var ip *int   
  
    // 指针变量的存储地址
    ip = &a  
  
    fmt.Printf("a 变量的地址是: %x\n", &a  )
  
    // 指针变量的存储地址
    fmt.Printf("ip 变量的存储地址: %x\n", ip )
  
    // 使用指针访问值
    fmt.Printf("*ip 变量的值: %d\n", *ip )
  }
  
  /** 输出 
   a 变量的地址是: 20818a220
   ip 变量的存储地址: 20818a220
   *ip 变量的值: 20
  **/
  ```

  

  ### 4.空指针

  - 定义

    1. 当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。
    2. nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。
    3. 一个指针变量通常缩写为 ptr。

    ```go
    /**
     1.空指针实例
    **/
    package main
    
    import "fmt"
    
    func main() {
      var  ptr *int
      // ptr的值为：0
      fmt.Printf("ptr 的值为 : %x\n", ptr  )
    }
    
    /**
     2.空指针判断
    **/
    if(ptr != nil)    // ptr 不是空指针
    if(ptr == nil)    // ptr 是空指针
    ```

    

  

  



